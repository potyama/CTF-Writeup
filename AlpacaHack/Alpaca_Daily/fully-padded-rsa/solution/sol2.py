from sympy import gcd, gcdex, invert
from Crypto.Util.number import long_to_bytes, bytes_to_long
from sage.all import *
import cuso

n = 91102717210596990388603678426683097953697889897819753293818443119019220403217013812232251320814152567699322671590559119510246139859891156830672838769529887961956970370968572962306584295059185945752892892100975462391203805852473243296747559459800718013816237662990504689724747628304890125129146326331097856907
c1 = 84316690833236468829386139306045298111202426584048821548102362931269993141514516100633466389955824290011995159677864206138653174440904170622039293036862729884826231898868928186453091113165643576890891297150845933751243965934735328928976655465009980896153972226679588496970771925581698573227941539852081781874
c2 = 74682069306151159606579889187354529286195652598555930926994495384029865435810129236911316774977007932641783161876484392995815937986886903514990618178943843429073696833993271982336114314882872652681858748846455760309012235191324385691614015531641062111894149446939460102878320469041435024347449132388644171970
len_flag = 40

def modexp(base, exp, mod):
    if exp >= 0:
        return pow(base, exp, mod)
    base_inv = invert(base, mod)
    return pow(base_inv, -exp, mod)

e1 = 65517
e2 = 65577

g = gcd(e1, e2)
assert g == 3

e1p = e1 // g
e2p = e2 // g

u, v, g2 = gcdex(e1p, e2p)
u = int(u)
v = int(v)
assert g2 == 1

m1 = modexp(c1, u, n)
m2 = modexp(c2, v, n)
m3 = (m1 * m2) % n

n_bytes =  long_to_bytes(n)
prefix_bytes = n_bytes[:-len_flag]
Prefix = bytes_to_long(prefix_bytes)

x = var('x')
m_poly = Prefix * (1 << (8 * len_flag)) + x
f = m_poly**3 - int(m3)
relations = [f]
bounds = {
    x: (0, 1 << (8 * len_flag))
}

roots = cuso.find_small_roots(
    relations,
    bounds,
    modulus=n,
)
assert len(roots) > 0
root = roots[0]   
x_val = int(root[x])
print(f"flag:{long_to_bytes(x_val).decode()} ")