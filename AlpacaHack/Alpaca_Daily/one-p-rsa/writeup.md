# RBG
authored by soon-haari_

> RBG stands for RSA + SBG + LCG! To learn about them, please check out lecture1.mp4.

## Challenge

```python
from Crypto.Util.number import *

PBITS, NDAT = 137, 13

with open("flag.txt", "rb") as f:
    m = int.from_bytes(f.read())

N = getPrime(PBITS) * getPrime(PBITS)
e = getRandomRange(731, N)
print(f"{N = }")

lcg = lambda s: (s * 3 + 1337) % N

for i in range(NDAT):
    print(pow(m, e := lcg(e), N))
```

## Solution

Let’s analyze the ciphertexts printed by the program. The *i*-th ciphertext can be written as:

$$
c_i \equiv m^{e_i} \pmod{N}
$$

Now consider the \((i+1)\)-th ciphertext:

$$
c_{i+1} \equiv m^{e_{i+1}} \pmod{N}
$$

Here, \(e_{i+1}\) is generated by the LCG:

$$
e_{i+1} \equiv 3e_i + 1337 \pmod{N}
$$

If we rewrite this as an integer equation (introducing a carry term), we get:

$$
e_{i+1} = 3e_i + 1337 - k_i N
$$

where \(k_i \in \{0,\dots,3\}\).

Therefore,

$$
\begin{aligned}
c_{i+1}
&\equiv m^{e_{i+1}}
\equiv m^{3e_i + 1337 - k_i N} \\
&\equiv (m^{e_i})^3 \cdot m^{1337} \cdot (m^N)^{-k_i} \pmod{N}.
\end{aligned}
$$

For simplicity, define \(X = m^{1337}\) and \(Y = m^N\). Since \(m^{e_i} \equiv c_i\), we obtain:

$$
c_{i+1} \cdot c_i^{-3} \equiv X \cdot Y^{-k_i} \pmod{N}.
$$

Because \(0 \le e_i \le N-1\) and \(0 \le e_{i+1} \le N-1\),

$$
3e_i + 1337 \le 3(N-1) + 1337 = 3N + 1334.
$$

If \(k_i \ge 4\), then

$$
3e_i + 1337 - 4N \le -N + 1334 < 0,
$$

which would make \(e_{i+1}\) negative, contradicting \(0 \le e_{i+1}\). Hence \(k_i\) must be one of \(0,1,2,3\).


We still don’t know \(X\), so we want to eliminate it. Taking the ratio of the right-hand sides for indices \(i\) and \(i+1\),

$$
\frac{X Y^{-k_i}}{X Y^{-k_{i+1}}} \equiv Y^{k_{i+1}-k_i} \pmod{N}.
$$

From

$$
c_{i+1} \cdot c_i^{-3} \equiv X \cdot Y^{-k_i} \pmod{N},
$$

we can also rearrange to

$$
X \equiv \left(c_{i+1} \cdot c_i^{-3}\right) \cdot Y^{k_i} \pmod{N},
$$

which means we can generate candidates of \(X\) once we have a candidate \(Y\).


Recall \(X = m^{1337}\) and \(Y = m^N\). They share the same base \(m\), so:

$$
X^N = m^{1337N}, \quad Y^{1337} = m^{1337N}.
$$

Thus, a correct pair \((X,Y)\) must satisfy:

$$
X^N \equiv Y^{1337} \pmod{N}.
$$


Once we have valid \(X\) and \(Y\), consider:

$$
XY \equiv m^{1337} \cdot m^N \equiv m^{1337+N} \pmod{N}.
$$

This still doesn’t directly give \(m\). Instead, raise them to powers \(a,b\):

$$
X^a Y^b \equiv m^{1337a + Nb} \pmod{N}.
$$

So if we find \(a,b\) such that

$$
1337a + Nb = 1,
$$

then:

$$
X^a Y^b \equiv m \pmod{N}.
$$

We can obtain such \(a,b\) using the extended Euclidean algorithm on \((1337, N)\).

## Solver

```python
from gmpy2 import powmod, gcdext
from Cryptodome.Util.number import inverse, long_to_bytes

N = 9288011389664837847963670837039196937548434573294469245501561784245642854634445047
cts = [
    7827437377925724428078233147899924081225364249930858942421079276821876942757073519,
    8887391738833944793881713037947023989163050343070393147424888589467627754249865604,
    8081548039727189478984198619032683177557008617453299085364096689176320484341697433,
    2275794279542811986322743644529192750108107184530803067791576158460846098638595919,
    6253142316263707598596838911072529989608774170182629190175128689020135811837569575,
    4733751513227945548879795301848782446340444473234631092994528819564169644364997232,
    7059294752711247585748476830322929650455626597483726834273561488576645863895400850,
    3416115616735235302679100710807631760495960686259891905227746706138654756842094326,
    8925820570540264143648581237815478995705636946118008059750128065916255778832895553,
    2892105289971843001930724217759034130633547138605066058109243908372747042621581984,
    314392853155476706788704773868088966795343394149871206877830575819199838027511362,
    4327945167964771727885647567828770187834470062965467452997985192630056416939883267,
    5004179351047061632898561578033712835850283897910028694457603173176131447102750100,
]

def powmod_signed(base, e, mod):
    if e >= 0:
        return powmod(base % mod, e, mod)
    inv_base = inverse(base, mod)
    return powmod(inv_base, -e, mod)

def solve():
    A = []
    for i in range(len(cts) - 1):
        A.append((cts[i + 1] * inverse(powmod(cts[i], 3, N), N)))

    B = []
    for i in range(len(A) - 1):
        B.append((A[i] * inverse(A[i + 1], N)))

    for Y in B:
        for i in range(4):
            for k in range(4):
                X = (A[i] * powmod(Y, k, N))
                if pow(X, N, N) != pow(Y, 1337, N):
                    continue
                g, a, b = gcdext(1337, N)
                m = (powmod_signed(X, int(a), N) * powmod_signed(Y, int(b), N)) % N
                print(long_to_bytes(m).decode())
                return 

solve()
```
Flag: `Alpaca{Thanks_SuperBeetleGamer!}`
